### 分布式理论
#### 一) CAP定理
##### 什么是CAP
一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。

|选项|描述|
|:--:|:--:|
|C|一致性，指数据在多个副本之间能够保持一致（严格的一致性）|
|A|可用性 指系统提供的服务必须一直处于可用状态，每次请求都能获取到非错的响应---但是不保证数据是最新的|
|P|分区容错 分布式系统在遇得到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络发生瘫痪|

什么是分区?  
在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域。这就是分区。  

##### 为什么只能3选2
整个系统由两个节点配合组成，之间通过网络通信，当节点 A 进行更新数据库操作的时候，需要同时更新节点 B 的数据库（这是一个原子的操作）。

上面这个系统怎么满足 CAP 呢？C：当节点A更新的时候，节点B也要更新，A：必须保证两个节点都是可用的，P：当节点 A,B 出现了网络分区，必须保证对外可用。

可见，根本完成不了，只要出现了网络分区，A 就无法满足，因为节点 A 根本连接不上节点 B。如果强行满足 C 原子性，就必须停止服务运行，从而放弃可用性 C。

组合：  

|组合|分析结果|
|:--:|:--:|
|CA|满足原子和可用，放弃分区容错。说白了，就是一个整体的应用。|
|CP|满足原子和分区容错，也就是说，要放弃可用。当系统被分区，为了保证原子性，必须放弃可用性，让服务停用。|
|AP|满足可用性和分区容错，当出现分区，同时为了保证可用性，必须让节点继续对外服务，这样必然导致失去原子性。|

---
#### 二）BASE理论
BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。

Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：
> 既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

##### Basically Available(基本可用)
什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：
- 响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而基本可用的搜索引擎可以在 1 秒作用返回结果。
- 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

##### Soft state（软状态）
什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。  
软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

##### Eventually consistent（最终一致性）
上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性。从而达到数据的最终一致性。这个时间期限取决于网络延时，系统负载，数据复制方案设计等等因素。  
稍微官方一点的说法就是：
> 系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。


而在实际工程实践中，最终一致性分为 5 种：

1. 因果一致性（Causal consistency）  
指的是：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。
2. 读己之所写（Read your writes）  
这种就很简单了，节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。
3. 会话一致性（Session consistency）  
会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。
4. 单调读一致性（Monotonic read consistency）  
单调读一致性是指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。
5. 单调写一致性（Monotonic write consistency）  
指一个系统要能够保证来自同一个节点的写操作被顺序的执行。


然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。

##### 总结
总的来说，BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的。

---
#### 三）2PC
##### 前言
为了使系统尽量能够达到 CAP，于是有了 BASE 协议，而 BASE 协议是在可用性和一致性之间做的取舍和妥协。
人们往往需要在系统的可用性和数据一致性之间反复的权衡。于是呢，就产生我们标题中的一致性协议，而且还不止一个呢。
为了解决分布式问题，涌现了很多经典的算法和协议，最著名的就是二阶段提交协议，三阶段提交协议，Paxos 算法。
本文重点介绍二阶段提交协议，简称 2PC。
##### 什么事2PC
在分布式系统中，会有多个机器节点，因此需要一个协调者，而各个节点就是参与者，而协调者统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点就是参与者。  
协调者最终决定这些参与者是否要把事务真正进行提交。基于该思想有了二阶段提交和三阶段提交。  
##### 2PC 阶段一
1. 事务询问
协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。
2. 执行事务
各参与者节点执行事务操作，并将undo和redo信息计入事务日志中。
3. 各参与者向协调者反馈事务询问的响应
如果参与者成功执行了事务操作，那么久反馈给协调者Yes响应。表示事务执行成功。如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行。  

从上面可以感觉到有一个所谓的投票阶段，所有的节点都要投票决定是否执行事务操作。

##### 2PC 阶段二
在阶段二，会根据阶段一的投票结果执行两种操作：执行事务提交，中断事务。  
执行事务提交步骤如下：
1. 发送提交请求：协调者向所有参与者发出commit请求
2. 事务提交：参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。
3. 反馈实物提交结果，参与者在完成事务提交之后，向协调者发送ack信息
4. 协调者接收到所有参与者反馈的Ack信息之后完成事务。

中断事务步骤如下：
1. 发送回滚请求：协调者向所有的参与者发送rollback请求
2. 事务回滚：参与者接收到rollback请求后，会利用其在阶段一记录的undo信息来执行十五混沌操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3. 反馈事务回滚结果，参与者在完成事务回滚之后，向协调者发送ACK信息
4. 中断事务，协调者接收到所有参与者反馈的ACK信息之后，完成事务中断操作。  

**核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看成一个强一致性的算法。**

##### 优缺点
优点：原理简单，实现方便  
缺点：同步阻塞，单点问题，数据不一致，过于保守  
1. 同步阻塞
在二阶段提交的过程中，所有的节点都在等待其他节点的响应。无法进行其他的操作，这种同步阻塞极大的限制了分布式系统的性能。
2. 单点问题
协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程都无法运转，更重要的是，其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。
3. 数据不一致
假设当协调者向所有的参与者发送commit请求之后，发生了局部网络异常或者是协调者在尚未发送完所有commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求，这将导致严重的数据不一致。
4. 过于保守
如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的化，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。

##### 总结
由于 Base 理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法或者说协议，这些协议设计的目的，就是能让分布式系统能够在可用性和一致性之间取得一个很好的平衡，能够基本可用。 比如 2PC，two-phase commit，分为两个阶段提交一个事务：投票，执行。通过协调者和各个参与者的配合，实现一致性协议。  
当然，他也是有去缺点的，比如同步阻塞的时候性能较低，协调者的单点问题，网络故障可能引起的数据不一致的问题，执行策略过于保守的问题等等。  
这些问题，将在另一个算法 3PC 中解决。  

---
#### 四）3PC
为了弥补2PC的缺点，产生了3PC  
##### 什么是三阶段提交 3PC
3PC 分为三个阶段
1. canCommit
2. preCommit
3. doCommit

就是将二阶段提交的提交阶段一分为二。

##### canCommit 阶段
1. 事务询问，协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各个参与者的响应。
2. 各参与者想协调者反馈询问响应。参与者收到来自协调者的CanCommit请求，如果参与者认为自己可以顺利执行，返回Yes，否则返回No

##### preCommit
协调者在得到所有的参与者的响应之后，会根据结果执行两种操作，执行事务预提交，中断事务  
1. 执行事务预提交，
  - 发送预提交请求：协调者向所有参与者节点发送PreCommit的请求，并进入Prepared状态。
  - 事务预提交：参与者收到PreCommit请求后，会执行事务操作，对应于2PC中的执行十五，也会Undo和Redo信息记录到事务日志中。
  - 各参与者向协调者反馈事务执行的结果，如果参与者成功执行了事务，就反馈Ack响应，同时等待指令提交（commit）或者终止（abor）
2. 中断事务
  - 发送中断请求：协调者向所有参与者节点发出abort请求
  - 中断事务：参与者如果收到abort请求或者超时，就会中断事务
##### doCommit
1. 执行提交
  - 发送提交请求：进入这一阶段如果协调者正常工作，并且接收到所有参与者的ack响应，那么协调者将从预提叫状态变为提交状态，并向所有参与者发送doCommit请求
  - 事务提交 参与者收到doCommit请求后，会正式执行事务提交操作，并在完成之后释放在整个事务中占用的事务资源。
  - 反馈事务提交结果，参与者完成事务提交之后，向协调者发送ack消息
  - 完成事务  协调者接收到所有参与者反馈的Ack消息后，完成事务。
2. 中断事务
假设有任何参与者反馈了 no 响应，或者超时了，就中断事务。
  - 发送中断请求：协调者向所有的参与者节点发送 abort 请求。
  - 事务回滚：参与者接收到 abort 请求后，会利用其在二阶段记录的 undo 信息来执行事务回滚操作，并在完成回滚之后释放整个事务执行期间占用的资源。
  - 反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 消息。
  - 中断事务：协调者接收到所有的 Ack 消息后，中断事务。

注意：一旦进入第三阶段，可能出现2种故障：
1. 协调者出现问题
2. 协调者和参与者之间网络故障  

一旦出现任意一种问题，最终都会导致参与者无法收到doCommit 请求或者abort请求，针对这种情况，参与者会在等待超时之后继续进行事务提交。

##### 总结
优点：相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的），并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）。

缺点：如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题。

---
#### 五）Paxos 算法

世界上只有一种一致性算法，那就是Paxos --- Leslie Lamport

##### paxos 解决了什么问题
解决了一致性问题
##### 什么是一致性问题？
在一个分布式系统中，有一组的 process，每个 process 都可以提出一个 value，consensus 算法就是用来从这些 values 里选定一个最终 value。如果没有 value 被提出来，那么就没有 value 被选中；如果有1个 value 被选中，那么所有的 process 都应该被通知到。  
性需要进行口述paxos算法

---
#### 六）zab协议
##### 什么是zab协议？
zab协议全称zookeeper atomic broadcast （zookeeper 原子广播协议）   
zk 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采用了 ZAB 协议。   
ZAB 协议定义：ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 崩溃恢复 和 原子广播 协议。下面我们会重点讲这两个东西。  
基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性。数据通过leader进行写入数据，然后同步到follower。从而保证数据的一致性。  
复制过程类似于2PC，ZAB只需要有一般以上返回Ack信息就可以执行提交。大大减少了同步阻塞，也提高了可用性。  
整个zk都是在 消息广播和 崩溃恢复之间进行切换的，leader正常则处于消息广播模式，当leader 不可用，则处于崩溃恢复。  

##### 消息广播
ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。  
**基本上整个广播流程分为2个步骤**
1. 将数据都复制到Follow中；  
2. 等待Follower回应Ack，最低超过半数即成功
3. 超过半数成功回应，则执行commit，同时提交自己

通过以上 3 个步骤，就能够保持集群之间数据的一致性。实际上，在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，避免同步，实现异步解耦。  

**一些细节**
1. Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 兮协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理。
2. 在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。
3. zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的请求，也会转发到 Leader 服务器进行处理。
4. 实际上，这是一种简化版本的 2PC，不能解决单点问题。等会我们会讲述 ZAB 如何解决单点问题（即 Leader 崩溃问题）。

##### 崩溃恢复
leader 崩溃了怎么办？还能保证数据的一致么？如果leader先本地提交了，然后commit请求没有发送出去，怎么办？  
这时候会进入我们说的崩溃恢复模式。  
假设1：Leader 在复制数据给所有 Follwer 之后崩溃，怎么办？  
假设2：Leader 在收到 Ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？  
针对这些问题，ZAB 定义了 2 个原则：
>ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。
ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。

**所以zab设计了下面这样一个选举算法**
能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。  
如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群总所有机器编号（即 ZXID 最大）的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。  
而且这么做有一个好处是：可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。  
这样，我们刚刚假设的两个问题便能够解决。假设 1 最终会丢弃调用没有提交的数据，假设 2 最终会同步所有服务器的数据。这个时候，就引出了一个问题，如何同步？  

##### 数据同步
当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader服务器首先曲儿额嗯事务是否已经被半数的Follwer提交了，即是否完成了数据同步，目的是保持数据一致。  
当所有的Follower 服务器都成功同步之后，Leader 会将这些服务器加入可用服务器列表中。  
实际上，Leader 服务器处理或丢弃事务都是依赖着ZXID的，那么这个ZXID是如何产生的呢？  
在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。  
而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值，然后再对这个值加一。  
高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。  
当 Follower 链接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。  
