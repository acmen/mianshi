### 高并发系统下幂等性
#### 幂等性概念
针对一个操作无论执行多少次返回的结果都一致。

#### 如何实现幂等性
首先针对不同的操作，主要分为查询和修改，查询的话一般都是幂等的，所以在dubbo中会直接使用默认的容错机制，并且设置最大的重试次数。还有一些修改操作也是幂等的比如进行删除操作等。这个也可以直接使用默认容错机制。针对不是幂等的修改操作，可以使用一种容错的配置比如如果报错直接进行异常抛出，不进行重试等。但是还会存在一些情况，比如超时异常，或者重复提交等。针对该异常可以讲请求的参数中确认一个唯一的key和操作行为生成一个全局唯一的key值，比如账单的修改，可以使用账单id+操作行为（也可以在请求参数中生成一个随机的token值）作为唯一的key值，在redis中设置setnx，如果存在则会直接抛出异常。具体的实现可以使用spring的切面变成，自己定一个一个注解，如果方法存在该注解，则会根据方法的参数自动的去进行上面 的幂等性判断，并在方法结束后进行redis的缓存清除。并且为了防止程序异常终止等，会设置redis key的最长有效期，比如设置10min等。

#### 幂等性应用场景
1. token防止重复提交
每一次的请求需要带上token值信息，如果重复提交则进行错误的返回。
2. 悲观锁
直接进行锁表操作，如果该条记录正在进行操作，则直接锁定记录。这种一般伴随着事务操作等。
3. 乐观锁
对于每条记录加上一个version，只会更新固定version的数据。如果version变更则更新失败。
4. 分布式锁
类似于上面的使用redis作为保存key的方式，本身具有分布式锁的功能。关键就是做一个全局唯一的id。
5. 状态机幂等
对于一个存在状态变化的数据，状态只会沿着状态变更的路线进行变化，如果一个请求是从一个老的状态进行变化则会直接进行异常处理。例子，比如未付款的账单超过了一定的时长会自动的变为失效的账单。采用发送消息的方式进行处理，如果消息队列发生堵塞，则会出现实际账单已经支付，但是等到这个信息进行消费的时候不应该再进行处理，因为状态已经变更了。这时候可以同一的做一个状态机，里面会进行状态的判断等。
6. 对外提供接口如何幂等
对外提供的接口要求有一个唯一的traceId, 并根据source（请求源）+ traceId 进行幂等判断。
