### zk 面试题
#### zookeeper 是什么？
zookeeper是一个分布式应用程序协调系统。他是集群的监管者，监控集群中各个节点的状态根据节点提交的反馈信息进行下一步合理操作。  
客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zk机器来处理，对于写请求，这个请求会同时发给其他的zk机器并且达成一致后，请求才会返回成功。因此，随着机器的增加，读请求的吞吐量会增加，而写请求的吞吐量会下降。  
有序性是zk中非常重要的一个概念，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳成为zxid(zookeeper transaction id) 而读请求只会相对于更新有序，也就是读请求的返回结果会带上这个zk得最新的zxid。

#### zookeeper 提供了什么？
文件系统  
通知机制

#### zookeeper 文件系统
zk提供一个多层级的节点命名空间（节点成为znode）与文件系统不同的是这些节点的都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不可以，zk为了保证高吞吐和低延时，在内存中维护了这个树状结构的目录结构，这种特性使得zk不能用于存放大量的数据，每个节点的存放数据上线是1M。

#### zab协议
ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。  
ZAB协议包括两种基本的模式：崩溃恢复和消息广播。  
当整个zookeeper集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。

#### 四种类型的znode 节点
1. 持久节点  客户端断开连接依然存在
2. 持久化顺序编号节点  zk给该节点进行了顺序编号
3. 临时节点  客户端断开连接删除
4. 临时顺序节点  zk给该节点进行顺序编号

#### 服务器角色
Leader
事务请求的唯一调度和处理者，保证集群事务处理的顺序性  
集群内部各服务的调度者  

Follower  
处理客户端的非事务请求，转发事务请求给Leader服务器  
参与事务请求Proposal的投票  
参与Leader选举投票  

Observer  观察者
3.3.0版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力  
- 处理客户端的非事务请求，转发事务请求给Leader服务器  
- 不参与任何形式的投票  


#### zookeeper 通知机制
client 端会给某个znode建立一个watcher事件，当该znode发生变化，这些client就会收到通知，然后client根据变化进行相应的业务处理。

#### zookeeper 做了什么
1. 命名服务
2. 配置管理
3. 集群管理
4. 分布式锁
5. 队列管理

#### zk的命名服务（文件系统）
命名服务是指通过指定的名字来获取资源或者服务地址，利用zk创建一个全局的路径，这额个路径可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等。

#### zk的配置管理（文件系统、通知机制）
程序分布式的部署在不同的机器上，将程序的配置信息存放在zk的znode上，当配置发生变化的时候，也就是znode发生变化，通过watcher通知到各个客户端，从而更改配置信息。

#### zk集群管理（文件系统、通知机制）
所谓的集群管理主要是：是否有机器退出或者加入，选举master  
对于第一点，所有的机器约定在父目录下创建临时节点，并且监听父目录下的节点数据变化，如果有机器断开连接或者加入了，则都会导致父目录下子目录的变化，这时候就会通知到到客户端，实现了机器动态的增加和删除的管理。  
对于选举master 可以采用临时有序节点，选择序号最小的机器作为master等。还有其他的一些选举master的思路。

#### Zookeeper分布式锁（文件系统、通知机制）
因为zk本身的一致性，所我们可以通过创建节点，必定有一个创建成功，如果创建成功代表获取了锁，如果创建失败则监听该节点，如果该节点被删除，则可以创建节点进行锁的获取。

#### Zookeeper队列管理（文件系统、通知机制）
在特定的目录下创建持久有序节点，创建成功通知等待的队列，队列删除序列号最小的节点来进行消费，这个场景下的znode用来存储消息。

#### Zookeeper数据复制
zk作为一个集群提供一致的数据服务，自然要所有机器间做数据复制，数据复制的好处：
1. 容错，一个节点出错，不至于让整个系统停止工作，别的节点可以接管她的工作。
2. 提高系统的扩展能力，把负载分不到多个节点上，或者增加节点来提高系统的负载能力
3. 提高性能，让客户短本地访问就近的节点，提高用户访问速度。

#### Zookeeper工作原理
Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。

#### zookeeper是如何保证事务的顺序一致性的？
zk才用了递增的事务id来标识，所有的提交都被带上了该zxid，zxid是一个64位的数字，高32位是epoch,用来标识leader是否发生变化，如果信的leader产生出来，epoch会递增，低32位是递增计数，新的写请求过来，会根据数据库的两阶段过程，首先向所有的serveeer发出事务执行请求，如果超过一半的机器都能执行并且成功，那么就会开始执行。

#### Zookeeper 下 Server工作状态
每个server在工作过程中有三种状态  
LOOKING:当前不知道谁是leader，正在搜寻  
LEADING:当前server为leader
FOLLOWING:leader选举出来了，当前server与之同步
OBSERVING:观察者状态。表明当前服务器角色是Observer。

#### zookeeper是如何选取主leader的？
当leader 崩溃或者leader失去大部分的follwer，这是zk进入恢复模式，恢复模式会重新选择一个新的leader，让宿友的server恢复到一个正确的状态，zk的选举算法有两种，一种基于basic paxos 实现，一种基于 fast paxos 算法实现，系统默认使用 fasr paxos.  
**zk 选主流程(basic paxos)**
（1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；
（2）选举线程首先向所有Server发起一次询问(包括自己)；
（3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；
（4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；
（5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。

#### Zookeeper同步流程
选举完leader之后进入同步阶段  
1. leader 等待server 连接
2. follower 连接 leader 将最大的zxid 发送给leader
3. leader 根据 follower 最大的zxid确认同步点
4. 完成同步后通知follower 更新状态
5. follower 更新状态。接收client 请求。

#### 机器中为什么会有leader？
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader选举。

#### zk节点宕机如何处理？
zk本身是集群推荐最少配置3太服务器，保证当一个节点宕机，其他节点继续提供服务。  
如果follower宕机，因为zk有多个副本，所以数据并不会丢失。  
如果一个leader宕机那么会重新选举出最新的leader  
zk节点超过半数节点正常才能提供服务，如果宕机节点过多，集群失效。这个是为了防止脑裂。

#### zk 有几种部署模式
单机模式 伪集群模式 集群模式

#### zk 是否支持动态添加机器
逐个进行重启，因为本身有半数的机器提供服务，所以 并不影响集群提供服务。

#### zk的数据结构
zk命名空间中的znode 兼具 目录和文件两种特性，维护着数据、元数据、ACL、时间戳等数据结构。主要包含三部分  
1. stat状态信息，描述znode版本，权限等。
2. data 与该Znode关联的数据(配置文件信息、状态信息、汇集位置)，数据大小至多1M
3. children 该znode下的子节点

#### zk watch机制
zk可以对所有的读操作设置watch包含 exists() getChildren() getData() 当节点发生变化的时候会触发相应的操作。zk会向客户端发送且仅发送一条通知。

#### zk的读写
zookeeper的各个复制集节点（follower，leader，observer）都包含了集群所有的数据且存在内存中，像个内存数据库。更新操作会以日志的形式记录到磁盘以保证可恢复性，并且写入操作会在写入内存数据库之前序列化到磁盘。  
每个ZooKeeper服务器都为客户端服务。客户端只连接到一台服务器以提交请求。读取请求由每个服务器数据库的本地副本提供服务。更改服务状态，写请求的请求由zab协议处理。   
作为协议协议的一部分，来自客户端的所有写入请求都被转发到称为leader的单个服务器。其余的ZooKeeper服务器（称为followers）接收来自领导者leader的消息提议并同意消息传递。消息传递层负责替换失败的leader并将followers与leader同步。  
ZooKeeper使用自定义原子消息传递协议zab。由于消息传递层是原子的，当领导者收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。


#### zk paxos 算法
参考 [paxos算法](https://blog.csdn.net/liuyuehu/article/details/52136945)  

[paxos 总结](./paxos.md)  
[zk简述](https://www.cnblogs.com/uncleData/p/9704934.html)

#### zab协议详解
参考[分布式理论](https://www.cnblogs.com/stateis0/category/1206895.html)

[分布式理论](./分布式理论.md)
