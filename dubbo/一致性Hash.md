### 一致性Hash算法
如果采用hash(object)%N算法，那么在有机器添加或者删除后，映射关系就变了，很多原有的缓存就无法找到了。
一致性hash：添加删除机器前后映射关系一致，当然，不是严格一致。实现的关键是环形Hash空间。将数据和机器都hash到环上，数据映射到顺时针离自己最近的机器中。
 一致性hash单调性体现在:  
无论是新增主机还是删除主机,被影响的都是离那台主机最近的那些节点,其他节点映射关系没有影响

一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：

1. 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。（虚拟节点解决）
2. 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
3. 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。
4. 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

#### 一致性Hash的具体算法
hash值包含0~2的32次方个数字，那么将这些值作为一个环形，每一个node节点会根据一定的hash算法分布在该环形上，先在对数值进行hash，也会落在该环形上，然后顺时针找到离该hash值最近的node节点，作为数据最终的落地节点。

主要解决的问题，因为对于分布式系统节点的动态增加和删除是常见的事情，针对普通的取模，会导致大批量的数据失效，因为被模的那个数字变了，所以会有很多的余数变化。而一致性hash则只会影响到临近的小批量数据。  
为了解决分散性，则出来一个虚拟节点的概念，简单说就是根据一定的规则一个节点变成多个节点。这样增加了数据的分散性。还有一个很重要的点就是保证hash算法能够平均的分配数据。否则也是会产生数据的不分散等问题。
