### dubbo 面试题
#### dubbo 是什么？
一个分布式，高性能的RPC框架，提供服务的自动注册，自动发现等高效的服务治理方案。

#### dubbo 包含哪些组成部分
provider 服务提供者  
consumer 服务消费者
registry 注册中心
monitor 监控中心
container 运行容器

#### dubbo 优缺点是什么
优点：
透明的远程方法调用，可以像调用本地方法一样调用远程方法。  
软负载均衡和容错机制  
服务注册中心自动注册和配置管理  
服务接口自动监控和管理

#### SPI 描述一下
dubbo采用类似于插件架构的方式，将原本需要和系统集成在一起的组件使用插件的方式进行剥离，并使其可以灵活的进行插入。用到的技术就是SPI（Service Provider Interface）。这是本身JAVA提供的一种支持扩展的方式，通过在META-INF目录下面创建services 目录，再添加接口全路径（xxx.xxx.AService） 文件，里面填写对应的实现。在需要使用的时候可以通过JAVA代码动态的获取具体的接口实现的方式。dubbo主要采用该方式实现插件化。并且对其进行了扩展，类似的再META-INF 目录下面创建dubbo文件夹，里面是接口全路径，紧接着里面是key-value的方式对每一个不同的实现取一个名称。  
使用@SPI("default-value") 注解标识一个接口属于扩展点，并且里面的value值是默认扩展点，对应于上面的key-value模式中的key。
使用@Adaptive注解在类上 ， 这个类就是缺省的适配扩展。@Adaptive 注解在扩展点 Interface 的方法上时 ， dubbo 动态的生成一个这个扩展点的适配扩展类（生成代码 ，动态编译实例化 Class ），名称为 扩展点 Interface 的简单类名 + $Adaptive ，例如 ： ProxyFactory$Adpative  。这么做的目的是为了在运行时去适配不同的扩展实例 ， 在运行时通过传入的 URL 类型的参数或者内部含有获取 URL 方法的参数 ，从 URL 中获取到要使用的扩展类的名称 ，再去根据名称加载对应的扩展实例 ，用这个扩展实例对象调用相同的方法  。如果运行时没有适配到运行的扩展实例 ， 那么就使用@SPI 注解缺省指定的扩展。通过这种方式就实现了运行时去适配到对应的扩展。

@Activate（注解在类型和方法上） ：@Activate注解在扩展点的实现类上 ，表示了一个扩展类被获取到的的条件，符合条件就被获取，不符合条件就不获取 ，根据@Activate中的 group 、 value 属性来过滤 。具体参考 ExtensionLoader 中的  getActivateExtension 函数。

扩展加载类：ExtensionLoader，这个类丰富了JAVA本身的SPI，实现了自动的注入其他的扩展点等功能。


#### dubbo 服务发现和注册的流程是什么？
provider 启动并将自己的IP，端口，提供的服务作为元数据发送到注册中心。
consumer 启动，并连接注册中心，获取provider的元数据信息并保存下来
调用需要的服务的时候使用的是本地的缓存数据。
provider的元数据变化则通过注册中心通知到consumer。
consumer 本地通过负载均衡等对服务进行调用。
如果注册中心挂掉，则还可以正常使用，因为使用的是本地的缓存元数据信息。

这样设计的好处 ：   
双向解耦，双方可以动态的增加节点。  
注册中心实现了高可用，可以动态的增加节点，一台宕机也可以切换到另一台。  
去中心化，双方不依赖于注册中心，即使注册中心短时间宕机不影响使用  
服务提供者无状态，宕机不影响  

#### dubbo 支持哪些协议？
1. dubbo协议，单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；
2. rmi协议 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。
多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；
3. webservice 协议 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；
4. http协议 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；
5. hession协议 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
等等。。。。。

默认推荐使用dubbo协议。

#### 服务治理

#### dubbo 注册中心
dubbo注册中心包含zk,redis,dubbo,广播形式，推荐使用zk，该方式采用watch方式进行通知。本身zk也属于一种分布式协调系统，适合作为注册中心使用。  

provider启动之后，会在zk上创建一个临时目录，xxx.xxx.AService/provider  上面会写入自己的URL等信息，
consumer 启动之后，如果配置ref 这个service 那么会监控该provider，并将自己的信息写入到xxx.xxx.AService/consumer 。

注册中心 主要保存的provider和consumer的元数据信息。还有就是监控等。   
支持下面的功能：
当提供者出现断电等异常停机时，注册中心能自动删除提供者信息
当注册中心重启时，能自动恢复注册数据，以及订阅请求
当会话过期时，能自动恢复注册数据，以及订阅请求
当设置<dubbo:registry check="false" />时，记录失败注册和订阅请求，后台定时重试
可通过设置<dubbo:registry username="admin" password="124" />设置zookeeper 登录信息
可通过<dubbo:registry group="dubbo" />设置 zookeeper 的根节点，不设置将使用无 根树


#### dubbo 负载均衡的模式有哪些
dubbo作为一个分布式框架，能够避免单点故障和支持服务的横向扩展。所以会有负载均衡的问题。先了解三个概念，
1. 负载均衡
2. 集群容错
3. 服务路由

一个请求，dubbo会根据路由规则路由到相应的provider，如果存在多个服务提供者会根据配置的负载均衡规则进行服务的选择，如果调用服务失败，则根据集群容错的规则进行重试等操作，默认的容错规则是进行重试，可以通过配置retries 参数配置重试的次数等信息。  
负载均衡的模式有下面几种：   
1. 随机负载均衡
可以在dubbo-admin上设置权重值，否则权重一样都是100，具体的算法是，比如一个10一个20，那么随机25 则使用第二个服务。跟抽奖是一个逻辑
2. 轮询  
按照顺序进行调用，也有权重的概念，但是首先不是随机的，而且如果有几起慢的话会存在一定的堵塞。因为会调用这个机器上的服务。
3. LeastActiveLoadBalance 最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。  
最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差，使慢的机器收到更少。每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。

4. 一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。
如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，映射关系就变了，很多原有的缓存就无法找到了。一致性hash：添加删除机器前后映射关系一致，当然，不是严格一致。实现的关键是环形Hash空间。将数据和机器都hash到环上，数据映射到顺时针离自己最近的机器中。

#### 一致性hash算法
详细见 [一致性Hash](一致性Hash.md)

#### 安全机制如何保证
不太进行考虑这块，因为本身是内部进行访问的，所以没有太大的必要做这些。

#### 如何防止重复调用？幂等性问题
详细见 [幂等性](./幂等性.md)

#### 容错机制
默认是Failover，对应的会配置一个retries参数，标识重试的次数，一般这种容错方式在接口是幂等性的时候才会这样处理，如果非幂等的修改这种会出问题。
对于非幂等性的接口建议使用Failfast，这种如果异常直接抛出异常。

#### 网关的实现
详细见 soul 网关实践 [soul网关](https://cloud.tencent.com/developer/article/1424331)  
有赞网关实践 [有赞网关](https://tech.youzan.com/api-gateway-in-practice/)

#### 如何防止服务的循环依赖
首先应该避免循环依赖这种，这个牵扯到针对服务的粒度的划分，应该将服务划分成各个的层级，ctl，facade, service 其中service不依赖于任何的其他服务化，属于底层服务。facade是服务的集合，并且减少facade之间的相互依赖，ctl作为接口层面进行服务化的调用。  
假如存在服务的相互依赖，应该进行治理，本身dubbo也可以设置 check=false 在启动的时候不进行服务的检测。这样保证了启动不报错。

#### 如何防止服务的雪崩
产生血崩的原因：因为服务提供者不可用，导致服务的调用者等待，无法响应，导致大量的请求线程同步等待导致资源耗尽。服务提供者可能因为超时重试，大批量请求同时进入，机器故障。   
解决办法  
1. 超时机制
设置超时时间防止长时间等待。这额个需要根据具体的业务可能产生的时间进行具体的配置，对于可能产生长时间的接口进行治理。
2. 服务限流
通过线程池+队列的方式，通过信号量的方式。比如商品评论比较慢，最大能同时处理10个线程，队列待处理5个，那么如果同时20个线程到达的话，其中就有5个线程被限流了，其中10个先被执行，另外5个在队列中
3. 服务熔断
这个熔断可以理解为我们自己家里的电闸。
当依赖的服务有大量超时时，在让新的请求去访问根本没有意义，只会无畏的消耗现有资源，比如我们设置了超时时间为1s，如果短时间内有大量请求在1s内都得不到响应，就意味着这个服务出现了异常，此时就没有必要再让其他的请求去访问这个服务了，这个时候就应该使用熔断器避免资源浪费
4. 服务降级
有服务熔断，必然要有服务降级。
所谓降级，就是当某个服务熔断之后，服务将不再被调用，此时客户端可以自己准备一个本地的fallback（回退）回调，返回一个缺省值。 例如：(备用接口/缓存/mock数据)，这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强，当然这也要看适合的业务场景

dubbo 采用Sentinel进行限流熔断等。

#### 服务熔断机制
参考Sentinel文档 [Sentinel](https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5)  需要详细阅读一下

#### 服务降级
参考Sentinel文档 [Sentinel](https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5) 需要详细阅读一下

#### 如果兼容多版本
通过不同的version来进行多版本的兼容。

#### 中台的概念
暂时忽略。。。

#### 分布式事务如何实现
详见 [分布式事务](./分布式事务.md)

#### 如何解决服务调用链过长的问题？

#### 说说核心的配置有哪些？
核心配置有 dubbo:service/ dubbo:reference/ dubbo:protocol/ dubbo:registry/ dubbo:application/ dubbo:provider/ dubbo:consumer/ dubbo:method/

#### 同一个服务多个注册的情况下可以直连某一个服务吗？
可以直连，修改配置即可，也可以通过telnet直接某个服务。
